from PIL import Image
import numpy as np
import cv2

# Step 1: get matrix of image using getImageMatrix
# Step 2: get chaotic sequence matrix using generatePermutationMap
# Step 3: XOR the matrixs from Step 1 & 2

class chaosTheory:
    def validateChaosKey(self,key1,key2):
        try:
            key1 = float(key1)
            key2 = float(key2)
            newKey = []
            newKey.append(key1)
            newKey.append(key2)
            return newKey
        except:
            return None

    # function to get an image matrix of the image
    def getImageMatrix(self,imageName):
        # opening and loading image
        im = Image.open(imageName)
        pix = im.load()

        # checking if image is greyscale or coloured
        color = 1
        if type(pix[0,0]) == int:
            color = 0

        # getting matrix of image
        image_size = im.size
        image_matrix = []
        for width in range(int(image_size[0])):
            row = []
            for height in range(int(image_size[1])):
                    row.append((pix[width,height]))
            image_matrix.append(row)

        return image_matrix,image_size[0],color

    # function to convert binary into decimal value (used when generating transformation matrix)
    def convertDecimal(self,bitSequence):
        decimal = 0
        for bit in bitSequence:
            decimal = decimal * 2 + int(bit)
        return decimal

    # function to obtain a transformation matrix using a permutation map generated by the henon chaotic system
    def generatePermutationMap(self,dimension, key):
        # definiing the initial values using the key
        x = key[0]
        y = key[1]

        sequenceSize = dimension * dimension * 8 # sequence size based on henon map sequence equation
        bitSequence = []    # bitSequence contains 8 bits
        byteArray = []      # byteArray contains m bitSequence
        TImageMatrix = []   # contains m * n byteArray

        try:
            for i in range(sequenceSize):
                # henon chaotic map formula; secret key inputted used as initial values (x,y)
                # parameters must be a = 1.4 and b = 0.3 for the system to be chaotic (else it wont be)
                xN = y + 1 - 1.4 * x**2
                yN = 0.3 * x
                x = xN # new x value
                y = yN # new y value

                # each value of xN is converted to either 0 or 1 based on a threshold value to ensure that sequence is balanced
                # thereshold set to 0.3992 based on research studies
                if xN <= 0.3992:
                    bit = 0
                else:
                    bit = 1

                # insert bits into bitSequence
                try:
                    bitSequence.append(bit)
                except:
                    bitSequence = [bit]

                # reduce the henon sequence by combining each consecutive 8 bits into 1 decimal value
                # this decimal value is then inserted into byteArray
                if i % 8 == 7:
                    decimal = self.convertDecimal(bitSequence)
                    try:
                        byteArray.append(decimal)
                    except:
                        byteArray = [decimal]
                    bitSequence = []

                # insert byteArray into the transformation matrix TImageMatrix
                byteArraySize = dimension*8
                if i % byteArraySize == byteArraySize-1:
                    try:
                        TImageMatrix.append(byteArray)
                    except:
                        TImageMatrix = [byteArray]
                    byteArray = []

            return TImageMatrix

        except OverflowError as error:
            return None


    def imgEncryption(self,imageName,key):
        imageMatrix, dimension, color = self.getImageMatrix(imageName)
        transformationMatrix = self.generatePermutationMap(dimension, key)

        # transformationMatrix will be None if there is overflow error
        if transformationMatrix != None:
            resultantMatrix = []
            # image encryption by XOR operation
            for i in range(dimension):
                row = []
                for j in range(dimension):
                    try:
                        if color:
                            row.append(tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]))
                        else:
                            row.append(transformationMatrix[i][j] ^ imageMatrix[i][j])
                    except:
                        if color:
                            row = [tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]])]
                        else:
                            row = [transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]
                try:
                    resultantMatrix.append(row)
                except:
                    resultantMatrix = [row]

            if color:
                im = Image.new("RGB", (dimension, dimension)) # RGB for coloured pixels
            else:
                im = Image.new("L", (dimension, dimension)) # L for black and white pixels

            pix = im.load()
            for x in range(dimension):
                for y in range(dimension):
                    pix[x, y] = resultantMatrix[x][y]
            return np.asarray(im)
        else:
            return None

    def imgDecryption(self,imageNameEnc, key):
        imageMatrix, dimension, color = self.getImageMatrix(imageNameEnc)
        transformationMatrix = self.generatePermutationMap(dimension, key)

        if transformationMatrix != None:
            henonDecryptedImage = []
            for i in range(dimension):
                row = []
                for j in range(dimension):
                    try:
                        if color:
                            row.append(tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]))
                        else:
                            row.append(transformationMatrix[i][j] ^ imageMatrix[i][j])
                    except:
                        if color:
                            row = [tuple([transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]])]
                        else :
                            row = [transformationMatrix[i][j] ^ x for x in imageMatrix[i][j]]
                try:
                    henonDecryptedImage.append(row)
                except:
                    henonDecryptedImage = [row]
            if color:
                im = Image.new("RGB", (dimension, dimension))
            else:
                im = Image.new("L", (dimension, dimension)) # L is for Black and white pixels

            pix = im.load()
            for x in range(dimension):
                for y in range(dimension):
                    pix[x, y] = henonDecryptedImage[x][y]
            return np.asarray(im)

        else:
            return None
